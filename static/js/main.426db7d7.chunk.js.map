{"version":3,"sources":["srgs.js","chartparser.js","grammars/appointmentGrammar.ts","dmAppointment.ts","runparser.js","grammars/warmupGrammar.ts","dmColourChanger.ts","grammars/smartHomeGrammar.ts","dmSmartHome.ts","dmMain.ts","dmRasaQuery.ts","index.tsx"],"names":["Grammar","root","this","$root","VOID","OneOf","NULL","GARBAGE","$check","i","checkSequenceExpansion","err","throwRuleError","Ref","ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","min","max","sequence","RepeatClass","ruleref","content","_string","toString","join","Infinity","message","error","undefined","TypeError","constructor","Array","name","String","checkExpansion","prototype","Number","LOG","str","clone","obj","temp","key","isEmpty","ob","hasOwnProperty","Chart","numberOfWords","passives","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","ActiveEdge","rest","rules","text","parse","words","grammar","filter","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","oneof","eval","position","leftCorners","pop","active","passive","person","day","8","time","9","10","11","12","1","2","3","4","5","yes_no_grammar","cancel","actions","say","send","_context","type","value","startRepromptTimer","delay","id","cancelRepromptTimer","resetRepromptCount","assign","repromptCount","context","promptAndAsk","prompt","repompt","initial","states","entry","on","ENDSPEECH","exit","ask","repromptCounter","cond","target","reprompt","nomatch","inGrammar","val","recResult","appointmentInformation","wholeDay","appointmentInformation2","createAppointmentPrompt","createAppointmentReprompt","dmAppointmentMachine","promptflow","init","welcome","who","confirmation","RECOGNISED","TIMER","whole_day","create_appointment","hist","history","common","help","giveup","appointment_created","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","repeat","parseInt","console","log","gram","result","sayColour","dmColourChangerMachine","askColour","stop","always","repaint","loadedGrammar","sayAction","useGrammar","object","action","dmSmartHomeMachine","askAction","doAction","dmMachine","CLICK","wait","RESPONSE","event","RESPONSE_ERROR","dmAppointment","onDone","dmTodo","dmTimer","dmColourChanger","dmSmartHome","dmRasaQueryMachine","QUERY","query","invoke","src","nluRequest","fetch","Request","proxyurl","method","headers","body","then","data","json","intent","onError","inspect","iframe","machine","Machine","dmMain","dmRasaQuery","asrtts","idle","LISTEN","SPEAK","ttsAgenda","recognising","ASRRESULT","STOP_LISTEN","progress","match","speaking","recLogResult","test","logIntent","nluData","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","useSpeechRecognition","onResult","listen","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.426db7d7.chunk.js","sourcesContent":["//\n//  srgs.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// encoding SRGS grammars in javascript\n\nexport function Grammar(root) {\n  this.$root = root;\n  \n  this.VOID = [OneOf([])];\n  this.NULL = [];\n  this.GARBAGE = []; \n  \n  this.$check = function() {\n    for (var i in this) {\n      if (i !== \"$root\" && i !== \"$check\") {\n\ttry {\n\t  checkSequenceExpansion(this[i]);\n\t} catch(err) {\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\n\t}\n      }\n    }\n  }\n}\n\nexport function WordSet(str) {\n  var words = str.split(/ +/);\n  var set = {};\n  for (var i in words) {\n    set[words[i]] = true;\n  }\n  return set;\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion constructors\n\n// sequences are ordinary arrays\nexport function Sequence(seq) {\n  return seq;\n}\n\nexport function Ref(ref) {\n  return new RefClass(ref);\n}\n\nexport function Tag(tag) {\n  return new TagClass(tag);\n}\n\nexport function OneOf(alternatives) {\n  return new OneOfClass(alternatives);\n}\n\nexport function Repeat(min, max, sequence) {\n  return new RepeatClass(min, max, sequence);\n}\n\nexport function Optional(sequence) {\n  return new RepeatClass(0, 1, sequence);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion classes\n\nexport function RefClass(ruleref) {\n  this.content = ruleref;\n  this._string = \"$\" + ruleref;\n  this.toString = function toString() {return this._string}\n}\n    \nexport function TagClass(tag) {\n  this.content = tag;\n  this._string = \"{\" + tag + \"}\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function OneOfClass(alternatives) {\n  this.content = alternatives;\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function RepeatClass(min, max, sequence) {\n  this.min = min;\n  this.max = max;\n  this.content = sequence;\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\n  this.toString = function toString() {return this._string}\n}\n\n//////////////////////////////////////////////////////////////////////\n// checking rule expansions\n\nexport function throwRuleError(message, error) {\n  if (error == undefined) {\n    throw TypeError(message);\n  } else {\n    throw TypeError(message + \"; \" + error.message);\n  }\n}\n\nexport function checkSequenceExpansion(sequence) {\n  try {\n    if (sequence.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\n    }\n    for (var i in sequence) {\n      if (sequence[i].constructor == Array) {\n\tcheckSequenceExpansion(sequence[i]);\n      } else if (sequence[i].constructor != String) {\n\tsequence[i].checkExpansion();\n      }\n    }\n  } catch(err) {\n    throwRuleError(\"When checking sequence expansion\", err);\n  }\n};\n\nRefClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nTagClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.content.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\n    }\n    for (var i in this.content) {\n      checkSequenceExpansion(this.content[i]);\n    }\n  } catch(err) {\n    throwRuleError(\"When checking OneOf content\", err);\n  }\n};\n\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\n    }\n    if (!(0 <= this.min && this.min <= this.max)) {\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\n    }\n    checkSequenceExpansion(this.content);\n  } catch(err) {\n    throwRuleError(\"When checking Repeat content\", err);\n  }\n};\n\n","//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n  //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){\n  if (obj == null || typeof(obj) != 'object') {\n    return obj;\n  }\n  var temp = new obj.constructor(); \n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n  return temp;\n}\n\n\nfunction isEmpty(ob){\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  }\n\n  // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n  this.add = function add(edge) {\n    var subchart, cat;\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }\n\n  // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n\tresults.push(finalEdges[i].out);\n      }\n    }\n    return results;\n  }\n  \n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  }\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n    for (var i in this.passives) \n      for (var j in this.passives[i]) \n\tfor (var k in this.passives[i][j])\n\t  edges.push(this.passives[i][j][k]);\n    return edges;\n  }\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n    for (var i in this.actives) \n      for (var j in this.actives[i]) \n\tfor (var k in this.actives[i][j])\n\t  edges.push(this.actives[i][j][k]);\n    return edges;\n  }\n\n  // Chart.statistics()\n  // return the number of edges in the chart\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \n    \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n  var chart = new Chart(words.length);\n  var agenda = [];\n\n  var leftCornerFilter;\n  if (filter == undefined) {\n    leftCornerFilter = function() {return true};\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    }\n  }\n  \n  // add an edge to the chart and the agenda, if it does not already exist\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n      switch (next.constructor) {\n\t\n      case Array:\n\t// the next symbol is a sequence\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n\treturn;\n\t\n      case SRGS.RepeatClass:\n\t// the next symbol is a repetition\n\tvar min = next.min;\n\tvar max = next.max;\n\t// skip repeat \n\tif (min <= 0) {\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\n\t}\n\t// repeat \n\tif (max > 0) {\n\t  var content = next.content;\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n\t}\n\treturn;\n\t\n      case SRGS.OneOfClass:\n\t// the next symbol is a disjunction\n\tvar oneof = next.content;\n\tfor (var i in oneof) {\n\t  var rhs = oneof[i].concat(rest);\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\n\t} \n\treturn;\n\t\n      case SRGS.TagClass:\n\t// the next symbol is a semantic action\n\tout = clone(out);\n\trules = clone(rules);\n\teval(next.content);\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\n\treturn;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    }\n    \n    // try to add the edge; if successful, also add it to the agenda\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  }\n  \n  // seed the agenda with the starting rule\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n  \n  // main loop\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start= edge.start;\n    var end  = edge.end;\n    var lhs  = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n      for (var i in actives) {\n\tvar active = actives[i];\n\tvar rules = clone(active.rules);\n\tvar text = active.text;\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\n\t    rules[edge.lhs] = text[edge.lhs];\n\t} else {\n        rules[edge.lhs] = clone(edge.out);\n    }\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content;\n      // combine\n      var passives = chart.passives[end][ref];\n      for (var i in passives) {\n\tvar passive = passives[i];\n\tvar rules = clone(edge.rules);\n\tvar text = edge.text;\n\trules[passive.lhs] = clone(passive.out);\n\ttext[passive.lhs] = passive.text;\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      }\n      // predict\n      if (ref in grammar) {\n\tif (leftCornerFilter(ref, end)) {\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n\t}\n      }\n\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n\n\n","export const grammar: { [index: string]: { person?: string, day?: string, time?: string } } = {\n    // Persons\n    \"John\": { person: \"John Appleseed\" },\n    \"Mary\": { person: \"Mary Shelly\" },\n    \"Jane\": { person: \"Jane Austen\" },\n    \"Albert\": { person: \"Albert Einstein\" },\n    \"Coco\": { person: \"Coco Chanel\" },\n    \"Rebecca\": { person: \"Rebecka Black\" },\n    \"Vlad\": { person: \"Vlad Maraev\" },\n    // Weekdays\n    \"on Monday\": { day: \"Monday\" },\n    \"on Tuesday\": { day: \"Tuesday\" },\n    \"on Wednesday\": { day: \"Wednesday\" },\n    \"on Thursday\": { day: \"Thursday\" },\n    \"on Friday\": { day: \"Friday\" },\n    \"on Saturday\": { day: \"Saturday\" },\n    \"on Sunday\": { day: \"Sunday\" },\n    \"Monday\": { day: \"Monday\" },\n    \"Tuesday\": { day: \"Tuesday\" },\n    \"Wednesday\": { day: \"Wednesday\" },\n    \"Thursday\": { day: \"Thursday\" },\n    \"Friday\": { day: \"Friday\" },\n    \"Saturday\": { day: \"Saturday\" },\n    \"Sunday\": { day: \"Sunday\" },\n    // Times\n    8: { time: \"8:00\" },\n    9: { time: \"9:00\" },\n    10: { time: \"10:00\" },\n    11: { time: \"11:00\" },\n    12: { time: \"12:00\" },\n    1: { time: \"1:00\" },\n    2: { time: \"2:00\" },\n    3: { time: \"3:00\" },\n    4: { time: \"4:00\" },\n    5: { time: \"5:00\" },\n    \"at 8 p.m.\": { time: \"8:00\" },\n    \"at 9 p.m.\": { time: \"9:00\" },\n    \"at 10 p.m.\": { time: \"10:00\" },\n    \"at 11 p.m.\": { time: \"11:00\" },\n    \"at 12 p.m.\": { time: \"12:00\" },\n    \"at 1 p.m.\": { time: \"1:00\" },\n    \"at 2 p.m.\": { time: \"2:00\" },\n    \"at 3 p.m.\": { time: \"3:00\" },\n    \"at 4 p.m.\": { time: \"4:00\" },\n    \"at 5 p.m.\": { time: \"5:00\" },\n    \"at 8\": { time: \"8:00\" },\n    \"at 9\": { time: \"9:00\" },\n    \"at 10\": { time: \"10:00\" },\n    \"at 11\": { time: \"11:00\" },\n    \"at 12\": { time: \"12:00\" },\n    \"at 1\": { time: \"1:00\" },\n    \"at 2\": { time: \"2:00\" },\n    \"at 3\": { time: \"3:00\" },\n    \"at 4\": { time: \"4:00\" },\n    \"at 5\": { time: \"5:00\" },\n}\n\nexport const yes_no_grammar: { [index: string]: {  } } = {\n    \"yes\": true,\n    \"you bet\": true,\n    \"yeah\": true,\n    \"no\": false,\n    \"no way\": false,\n    \"nope\": false,\n}\n","import { MachineConfig, send, Action, assign, actions } from \"xstate\";\n\nimport { grammar } from './grammars/appointmentGrammar'\nimport { yes_no_grammar } from './grammars/appointmentGrammar'\n\nconst { cancel } = actions;\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nconst startRepromptTimer: Action<SDSContext, SDSEvent> = send(\"TIMER\", { delay: 3000, id: \"repromptTimer\" })\nconst cancelRepromptTimer: Action<SDSContext, SDSEvent> = cancel(\"repromptTimer\")\nconst resetRepromptCount: Action<SDSContext, SDSEvent> = assign({ repromptCount: context => 0 })\n\nfunction promptAndAsk(prompt: Action<SDSContext, SDSEvent>, repompt: Action<SDSContext, SDSEvent>): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: \"prompt\",\n        states: {\n            prompt: {\n                entry: prompt,\n                on: {\n                    ENDSPEECH: \"ask\",\n                },\n                exit: startRepromptTimer\n            },\n            ask: {\n                entry: listen(),\n                exit: cancelRepromptTimer\n            },\n            repromptCounter: {\n                entry: [\n                    send('STOP_LISTEN'),\n                    assign({ repromptCount: context => context.repromptCount + 1 }),\n                    say(\"Hey, are you awake?\")\n                ],\n                on: {\n                    ENDSPEECH: [\n                        {\n                            cond: (context) => context.repromptCount > 3,\n                            target: \"#giveup\"\n                        },\n                        {\n                            target: \"reprompt\"\n                        }\n                    ]\n                },\n            },\n            reprompt: {\n                entry: repompt,\n                on: {\n                    ENDSPEECH: \"ask\",\n                },\n                exit: startRepromptTimer\n            },\n            nomatch: {\n                entry: say(\"Sorry, could you repeat that?\"),\n                on: { ENDSPEECH: \"reprompt\" }\n            },\n        }\n    })\n}\n\nfunction inGrammar(val: string, context: SDSContext): boolean {\n    return val in (grammar[context.recResult] || {})\n}\n\nfunction appointmentInformation(context: SDSContext): string {\n    var text = \"\"\n    if (context.wholeDay) {\n        text = `Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`\n    }\n    else {\n        text = `Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time}?`\n    }\n    return text\n}\n\nfunction appointmentInformation2(context: SDSContext): string {\n    var text = \"\"\n    if (context.wholeDay) {\n        text = `${context.person}. ${context.day}. Whole day. Create appointment?`\n    }\n    else {\n        text = `${context.person}. ${context.day}. ${context.time}. Create appointment?`\n    }\n    return text\n}\n\nconst createAppointmentPrompt: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: appointmentInformation(context)\n}))\n\nconst createAppointmentReprompt: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: appointmentInformation2(context)\n}))\n\nexport const dmAppointmentMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    id: \"appointment\",\n    initial: \"promptflow\",\n    entry: resetRepromptCount,\n    states: {\n        promptflow: {\n            id: \"promptflow\",\n            initial: \"init\",\n            states: {\n                init: {\n                    initial: \"welcome\",\n                    on: { ENDSPEECH: \"who\" },\n                    states: {\n                        welcome: {\n                            entry: say(\"Let's create an appointment\"),\n                        }\n                    }\n                },\n                who: {\n                    initial: \"promptAndAsk\",\n                    states: {\n                        promptAndAsk: {\n                            ...promptAndAsk(say(\"Whom are you meeting?\"), say(\"You are meeting whom?\")),\n                        },\n                        confirmation: {\n                            entry: [\n                                send((context) => ({\n                                    type: \"SPEAK\",\n                                    value: `OK. ${context.person}`,\n                                })),\n                                resetRepromptCount\n                            ],\n                            on: { ENDSPEECH: \"#promptflow.day\" }\n                        }\n                    },\n                    on: {\n                        RECOGNISED: [\n                            {\n                                cond: (context) => context.recResult === \"help\",\n                                target: \"#common.help\"\n                            },\n                            {\n                                cond: (context) => inGrammar(\"person\", context),\n                                actions: [\n                                    assign((context) => {\n                                        return { person: grammar[context.recResult].person }\n                                    })\n                                ],\n                                target: \".confirmation\"\n                            },\n                            { target: \".promptAndAsk.nomatch\" }\n                        ],\n                        TIMER: \".promptAndAsk.repromptCounter\"\n                    },\n                },\n                day: {\n                    initial: \"promptAndAsk\",\n                    states: {\n                        promptAndAsk: {\n                            ...promptAndAsk(say(\"On which day is your meeting?\"), say(\"Which day?\"))\n                        },\n                        confirmation: {\n                            entry: [\n                                send((context) => ({\n                                    type: \"SPEAK\",\n                                    value: `OK. ${context.day}`,\n                                })),\n                                resetRepromptCount\n                            ],\n                            on: { ENDSPEECH: \"#promptflow.whole_day\" }\n                        }\n                    },\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => context.recResult === \"help\",\n                            target: \"#common.help\"\n                        },\n                        {\n                            cond: (context) => inGrammar(\"day\", context),\n                            actions: assign((context) => {\n                                return { day: grammar[context.recResult].day }\n                            }),\n                            target: \".confirmation\"\n                        },\n                        { target: \".promptAndAsk.nomatch\" }\n                        ],\n                        TIMER: \".promptAndAsk.repromptCounter\"\n                    },\n                },\n                whole_day: {\n                    initial: \"promptAndAsk\",\n                    states: {\n                        promptAndAsk: {\n                            ...promptAndAsk(say(\"Will it take the whole day?\"), say(\"Whole day?\"))\n                        },\n                        confirmation: {\n                            entry: [\n                                send((context) => ({\n                                    type: \"SPEAK\",\n                                    value: `OK. ${context.wholeDay}`,\n                                })),\n                                resetRepromptCount\n                            ],\n                            on: {\n                                ENDSPEECH: [{\n                                    cond: (context) => context.wholeDay,\n                                    target: \"#promptflow.create_appointment\",\n                                },\n                                { target: \"#promptflow.time\" },\n                                ]\n                            }\n                        },\n                    },\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => context.recResult === \"help\",\n                            target: \"#common.help\"\n                        },\n                        {\n                            cond: (context) => context.recResult in yes_no_grammar,\n                            actions: [\n                                assign((context) => {\n                                    return { wholeDay: yes_no_grammar[context.recResult] }\n                                })\n                            ],\n                            target: \".confirmation\",\n                        },\n                        { target: \".promptAndAsk.nomatch\" }\n                        ],\n                        TIMER: \".promptAndAsk.repromptCounter\"\n                    }\n                },\n                time: {\n                    initial: \"promptAndAsk\",\n                    states: {\n                        promptAndAsk: {\n                            ...promptAndAsk(say(\"At what time is your meeting?\"), say(\"What time?\"))\n                        },\n                        confirmation: {\n                            entry: [\n                                send((context) => ({\n                                    type: \"SPEAK\",\n                                    value: `OK. ${context.time}`,\n                                })),\n                                resetRepromptCount\n                            ],\n                            on: { ENDSPEECH: \"#promptflow.create_appointment\" }\n                        },\n                    },\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => context.recResult === \"help\",\n                            target: \"#common.help\"\n                        },\n                        {\n                            cond: (context) => \"time\" in (grammar[context.recResult] || {}),\n                            actions:\n                                assign((context) => {\n                                    return { time: grammar[context.recResult].time }\n                                }),\n                            target: \".confirmation\",\n\n                        },\n                        { target: \".promptAndAsk.nomatch\" }\n                        ],\n                        TIMER: \".promptAndAsk.repromptCounter\"\n                    },\n                },\n                create_appointment: {\n                    initial: \"promptAndAsk\",\n                    states: {\n                        promptAndAsk: {\n                            ...promptAndAsk(createAppointmentPrompt, createAppointmentReprompt),\n                        },\n                    },\n                    on: {\n                        RECOGNISED: [{\n                            cond: (context) => context.recResult === \"help\",\n                            target: \"#common.help\"\n                        },\n                        {\n                            cond: (context) => yes_no_grammar[context.recResult] === true,\n                            target: \"#appointment_created\",\n                        },\n                        {\n                            cond: (context) => yes_no_grammar[context.recResult] === false,\n                            target: \"who\"\n                        },\n                        { target: \".promptAndAsk.nomatch\" }],\n                        TIMER: \".promptAndAsk.repromptCounter\"\n                    },\n                },\n                hist: {\n                    type: \"history\",\n                    history: \"shallow\"\n                },\n            },\n        },\n        common: {\n            id: \"common\",\n            states: {\n                help: {\n                    entry: say(\"This is a help message\"),\n                    on: { ENDSPEECH: \"#promptflow.hist\" },\n                },\n            },\n        },\n        giveup: {\n            id: \"giveup\",\n            entry: say(\"Bye bye!\"),\n            type: \"final\"\n        },\n        appointment_created: {\n            id: \"appointment_created\",\n            entry: say(\"Your appointment has been created!\"),\n            type: \"final\"\n        }\n    }\n})\n\n","//\n//  runparser.js\n//\n/*\n  The author or authors of this code dedicate any and all \n  copyright interest in this code to the public domain.\n*/\n\n\n// helper functions for the parser demo\n\nimport * as SRGS from './srgs'\n\nfunction getElement(id) {\n  return document.getElementById(id);\n}\n\nfunction appendElement(parent, element, text) {\n  var elem = document.createElement(element);\n  if (text)\n    elem.appendChild(document.createTextNode(text));\n  parent.appendChild(elem);\n  return elem\n}\n\nfunction runParser(input) {\n  var resultsDiv = getElement(\"results\");\n  resultsDiv.innerHTML = \"\";\n  var maybeFilter;\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\n    maybeFilter = filter;\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\n  }\n  var startTime = new Date();\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\n  var parseTime = new Date() - startTime;\n  var parseResults = parseChart.resultsForRule(grammar.$root);\n  \n  console.log(parseResults[0]);\n  \n  if (parseResults) {\n    for (var i in parseResults) {\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\n    }\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n  \n/*\n  if (parseResults) { \n    var resultList = appendElement(resultsDiv, \"OL\");\n    for (var i in parseResults) \n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n*/\n  var statistics = parseChart.statistics()\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\n}\n\nfunction runWordParser() {\n  runParser(getElement(\"input\").value.split(/\\s+/));\n}\n\nfunction runCharacterParser() {\n  runParser(getElement(\"input\").value.split(\"\"));\n}\n\nexport function loadGrammar(str) {\n    var dom = parseXML(str);\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\n    var grammar = new SRGS.Grammar(root);\n    var xrules = dom.getElementsByTagName(\"rule\");\n    for(var r=0; r < xrules.length; r++) {\n        var xrule = xrules[r];\n        var id = xrule.getAttribute(\"id\");\n        grammar[id] = processRuleExpansions(xrule);\n    }\n    return grammar;\n}\n\nfunction processRuleExpansions(xrule) {\n    var xitems = xrule.childNodes;\n    var rule = [];\n    for(var i=0; i < xitems.length; i++) {\n        if (xitems[i].nodeType == 3) {\n            var str = xitems[i].textContent.trim();\n            if (str != \"\") {\n                rule.push(str.split(/ +/));\n            }\n        } else if (xitems[i].nodeType == 1) {\n            if (xitems[i].nodeName == \"token\") {\n                rule.push(SRGS.Tag(xitems[i].textContent));\n            } else if (xitems[i].nodeName == \"ruleref\") {\n                var uri = xitems[i].getAttribute(\"uri\");\n                rule.push(SRGS.Ref(uri.slice(1)));\n            } else if (xitems[i].nodeName == \"tag\") {\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\n            } else if (xitems[i].nodeName == \"one-of\") {\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\n            } else if (xitems[i].nodeName == \"item\") {\n                var repeat = xitems[i].getAttribute(\"repeat\");\n                if (!repeat) {\n                    rule.push(processRuleExpansions(xitems[i]));\n                } else {\n                    var r = repeat.split(\"-\");\n                    var min = parseInt(r[0]);\n                    var max = parseInt(r[1]);\n                    max = (max) ? max : Infinity;\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\n                }\n            } else {\n                console.log(xitems[i]);\n            }\n        }\n    }\n\treturn rule;\n}\n\nfunction parseXML(text) {\n    if (typeof DOMParser != \"undefined\") {\n        // Mozilla, Firefox, and related browsers\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\n    }\n    else if (typeof ActiveXObject != \"undefined\") {\n        // Internet Explorer.\n        var doc = XML.newDocument();  // Create an empty document\n        doc.loadXML(text);            // Parse text into it\n        return doc;                   // Return it\n    }\n    else {\n        // As a last resort, try loading the document from a data: URL\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, false);\n        request.send(null);\n        return request.responseXML;\n    }\n};\n","export const grammar = `\n<grammar root=\"quotes\">\n  <rule id=\"quotes\">\n    <one-of>\n      <item>to do is to be<tag>out=\"socrates\";</tag></item>\n      <item>to be is to do<tag>out=\"sartre\";</tag></item>\n      <item>do be do be do<tag>out=\"sinatra\";</tag></item>\n    </one-of>\n  </rule>\n</grammar>\n`","import { MachineConfig, send, Action } from \"xstate\";\n\n// SRGS parser and example (logs the results to console on page load)\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/warmupGrammar'\n\nconst gram = loadGrammar(grammar)\nconst input = \"do be do be do\"\nconst prs = parse(input.split(/\\s+/), gram)\nconst result = prs.resultsForRule(gram.$root)[0]\n\nconsole.log(result)\n\nconst sayColour: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: `Repainting to ${context.recResult}`\n}))\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN'),\n            },\n        }\n    })\n}\n\n\nexport const dmColourChangerMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"askColour\" },\n            states: {\n                prompt: { entry: say(\"Let's change the colour!\") }\n            }\n        },\n        askColour: {\n            on: {\n                RECOGNISED: [\n                    { target: 'stop', cond: (context) => context.recResult === 'stop' },\n                    { target: 'repaint' }]\n            },\n            ...promptAndAsk(\"Tell me the colour\")\n        },\n        stop: {\n            entry: say(\"Ok\"),\n            always: 'init'\n        },\n        repaint: {\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: sayColour,\n                    on: { ENDSPEECH: 'repaint' }\n                },\n                repaint: {\n                    entry: 'changeColour',\n                    type: 'final'\n                }\n            }\n        }\n    }\n})\n","export const grammar = `\n<grammar root=\"command\">\n    <rule id=\"command\">\n        <ruleref uri=\"#polite\"/>\n        <one-of>\n            <item><ruleref uri=\"#on_off\"/><tag> out=rules.on_off; </tag></item>\n            <item><ruleref uri=\"#open_close\"/><tag> out=rules.open_close; </tag></item>\n        </one-of>\n        <ruleref uri=\"#polite\"/>\n    </rule> \n    <rule id=\"on_off\">\n        <ruleref uri=\"#on_off_action\"/>\n        <item repeat=\"0-1\">the</item>\n        <ruleref uri=\"#on_off_object\"/>\n        <tag>\n            out.action=rules.on_off_action;\n            out.object=rules.on_off_object;\n        </tag>\n    </rule> \n    <rule id=\"open_close\">\n        <ruleref uri=\"#open_close_action\"/>\n        <item repeat=\"0-1\">the</item>\n        <ruleref uri=\"#open_close_object\"/>\n        <tag>\n            out.action=rules.open_close_action;\n            out.object=rules.open_close_object;\n        </tag>\n    </rule> \n    <rule id=\"on_off_action\">\n        <one-of>\n            <item> turn off <tag> out = 'off'; </tag> </item>\n            <item> turn on <tag> out = 'on'; </tag> </item>\n        </one-of>\n    </rule> \n    <rule id=\"on_off_object\">\n        <one-of>\n            <item> light </item>\n            <item> lights <tag> out = 'light'; </tag></item>\n            <item> heat </item>\n            <item> AC <tag> out = 'air conditioning'; </tag></item>\n            <item> air-conditioning </item>\n        </one-of>\n    </rule>\n    <rule id=\"open_close_action\">\n        <one-of>\n            <item> open </item>\n            <item> close </item>\n        </one-of>\n    </rule> \n    <rule id=\"open_close_object\">\n        <one-of>\n            <item> window </item>\n            <item> door </item>\n        </one-of>\n    </rule>\n    <rule id=\"polite\">\n        <item repeat=\"0-1\">\n            <one-of>\n                <item> could you </item>\n                <item> would you </item>\n            </one-of>\n        </item>\n        <item repeat=\"0-1\">\n            <one-of>\n                <item> please </item>\n                <item> kindly </item>\n            </one-of>\n        </item>\n    </rule> \n</grammar>\n`","import { MachineConfig, send, Action } from \"xstate\";\n\n// SRGS parser and example (logs the results to console on page load)\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/smartHomeGrammar'\n\nconst loadedGrammar = loadGrammar(grammar)\n\nconst sayAction: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: useGrammar(context.recResult)\n}))\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction useGrammar(text: string): string {\n    const prs = parse(text.split(/\\s+/), loadedGrammar)\n    const result = prs.resultsForRule(loadedGrammar.$root)[0]\n    var output = \"\"\n    console.log(result)\n    if (result === undefined)\n    {\n        output = \"Sorry, I couldn't understand that.\"\n    }\n    else\n    {\n        output = \"OK! \" + result.object + \". \" + result.action + \".\"\n    }\n    return output\n}\n\nfunction promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN'),\n            },\n        }\n    })\n}\n\n\nexport const dmSmartHomeMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"askAction\" },\n            states: {\n                prompt: { entry: say(\"Welcome to smart home!\") }\n            }\n        },\n        askAction: {\n            on: {\n                RECOGNISED: [\n                    { target: 'doAction' }\n                ]\n            },\n            ...promptAndAsk(\"What do you want me to do?\")\n        },\n        doAction: {\n            entry: sayAction,\n            type: 'final'\n        }\n    }\n})\n","import { MachineConfig, send, Action, assign } from \"xstate\";\nimport { dmAppointmentMachine } from \"./dmAppointment\";\nimport { dmColourChangerMachine } from \"./dmColourChanger\";\nimport { dmSmartHomeMachine } from \"./dmSmartHome\";\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nfunction query(text: string): Action<SDSContext, SDSEvent> {\n    console.log(\"Sending query\")\n    return send((_context: SDSContext) => ({ type: \"QUERY\", value: text }))\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n\t    welcome: {\n\t        on: {\n\t    \t    RECOGNISED: {\n\t    \t        actions: send((context) => ({ type: \"QUERY\", value: context.recResult })),\n\t    \t        target: 'wait',\n                }\n            },\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Hi! What do you want me to do?\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {\n                    entry: listen(),\n                },\n            },\n\t    },\n        wait: {\n            on: {\n                RESPONSE: [\n                    {\n                        cond: (context, event) => event.value === \"appointment\",\n                        target: 'dmAppointment'\n                    },\n                    {\n                        cond: (context, event) => event.value === \"todo_item\",\n                        target: 'dmTodo'\n                    },\n                    {\n                        cond: (context, event) => event.value === \"timer\",\n                        target: 'dmTimer'\n                    },\n                    {\n                        cond: (context, event) => event.value === \"change_colour\",\n                        target: 'dmColourChanger'\n                    },\n                    {\n                        cond: (context, event) => event.value === \"smart_home\",\n                        target: 'dmSmartHome'\n                    },\n                    { target: 'nomatch' }\n                ],\n                RESPONSE_ERROR: {\n                    target: 'error'\n                }\n            }\n        },\n        error: {\n            entry: say(\"Oh no, an error!\"),\n            on: { ENDSPEECH: 'init' }\n        },\n        nomatch: {\n            entry: say(\"Sorry, I don't know how to do this.\"),\n            on: { ENDSPEECH: 'init' }\n        },\n        dmAppointment: {\n            ...dmAppointmentMachine,\n            onDone: {\n                target: 'init' \n            }\n        },\n        dmTodo: {\n            entry: say(\"Let's create a to-do item!\"),\n            on: { ENDSPEECH: 'init' }\n        },\n        dmTimer: {\n            entry: say(\"Let's set a timer!\"),\n            on: { ENDSPEECH: 'init' }\n        },\n        dmColourChanger: {\n            ...dmColourChangerMachine,\n            onDone: {\n                target: 'init' \n            }\n        },\n        dmSmartHome: {\n            ...dmSmartHomeMachine,\n            onDone: {\n                target: 'init' \n            }\n        },\n    },\n})","import { MachineConfig, send, assign, Action } from \"xstate\";\n\nconst proxyurl = 'https://cors-anywhere.herokuapp.com/';\nconst rasaurl = 'https://si-jon-nlu-app.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\n        body: `{\"text\": \"${text}\"}`\n    })).then(data => data.json());\n\nexport const dmRasaQueryMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                QUERY: {\n                    actions: assign((context, event) => { return { query: event.value } }),\n                    target:'query'\n                }\n            }\n        },\n\t    query: {\n\t        invoke: {\n                src: (context, event) => nluRequest(context.query),\n                onDone: {\n                    target: 'init',\n                    actions: [\n                        send((context, event) => ({ type: \"RESPONSE\", value: event.data.intent.name })),\n                        (context:SDSContext, event:any) => console.log(event.data)\n                        ]\n                },\n\t    \t    onError: {\n                    target: 'init',\n\t    \t        actions: [\n                        send((context, event) => ({ type: \"RESPONSE_ERROR\", value: event.data })),\n                        (context:SDSContext, event:any) => console.log(event.data)\n                    ]\n                }\n            }\n\t    }\n    }\n})\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, send, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmMain\";\nimport { dmRasaQueryMachine } from \"./dmRasaQuery\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\n\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dmMain: {\n            ...dmMachine,\n        },\n        dmRasaQuery: {\n            ...dmRasaQueryMachine,\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => {\n                                console.log('I was triggered during LISTEN')\n                                return { ttsAgenda: event.value } \n                            })\n                        }\n                    }\n                },\n                recognising: {\n                    initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        STOP_LISTEN: 'idle'\n                    },\n                    states: {\n                        progress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        case props.state.matches({ dmRasaQuery: 'query' }):\n            console.log('Waiting for rasa result')\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 60s linear\" }} {...props}>\n                    Waiting...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Listening.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            changeColour: asEffect((context) => {\n                console.log('Repainting...');\n                document.body.style.background = context.recResult;\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            })\n            /* speak: asEffect((context) => {\n\t     * console.log('Speaking...');\n             *     speak({text: context.ttsAgenda })\n             * } */\n        }\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}